import unittest
from unittest.mock import MagicMock, patch, mock_open
import cve_lookup
import threat_intelligence


class TestVulnerabilityModule(unittest.TestCase):

    def test_get_service_ssh(self):
        banners = {22: "SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3"}
        result = cve_lookup.get_service(banners)
        self.assertTrue(any("OpenSSH" in svc for svc, _ in result))

    def test_get_service_ftp(self):
        banners = {21: "220 vsFTPd 3.0.3"}
        result = cve_lookup.get_service(banners)
        self.assertTrue(any("vsFTPd" in svc for svc, _ in result))

    def test_get_service_http_server(self):
        banners = {
            80: "HTTP/1.1 200 OK Server: Apache/2.4.29 (Ubuntu) "
                "X-Powered-By: PHP/7.2.24"
        }
        result = cve_lookup.get_service(banners)
        found = [svc for svc, _ in result]
        self.assertIn("Apache", found)
        self.assertIn("PHP", found)

    def test_get_service_no_match(self):
        banners = {8080: "Nothing to match here"}
        result = cve_lookup.get_service(banners)
        self.assertEqual(result, [(None, None)])

    @patch("gzip.open")
    @patch("os.path.join", return_value="fakepath")
    def test_search_cve_by_service_version_returns_results(self, mock_join, mock_gzip_open):
        fake_cve_data = {
            "CVE_Items": [
                {
                    "cve": {
                        "CVE_data_meta": {"ID": "CVE-2021-0001", "ASSIGNER": "testassigner"},
                        "description": {
                            "description_data": [
                                {"value": "apache 2.4.29 remote vulnerability"}
                            ]
                        }
                    },
                    "publishedDate": "2021-01-01T00:00Z"
                }
            ]
        }
        mock_gzip_open.return_value.__enter__.return_value = MagicMock()
        with patch("json.load", return_value=fake_cve_data):
            results = cve_lookup.search_cve_by_service_version(
                ("Apache", "2.4.29"))
        self.assertTrue(any(r["cve_id"] == "CVE-2021-0001" for r in results))

    @patch("cve_lookup.get_service")
    @patch("cve_lookup.search_cve_by_service_version")
    def test_get_vul_with_service(self, mock_search_cve, mock_get_service):
        mock_get_service.return_value = [("Apache", "2.4.29")]
        mock_search_cve.return_value = [
            {"cve_id": "CVE-2020-1234", "description": "Fake vul",
                "published": "2020-12-01"}
        ]
        banners = {80: "Server: Apache/2.4.29"}
        vulns = cve_lookup.get_vul(banners)
        self.assertIn("Apache", vulns)
        self.assertEqual(vulns["Apache"][0]["cve_id"], "CVE-2020-1234")

    def test_get_service_multiple_banners(self):
        banners = {
            21: "220 vsFTPd 3.0.3",
            25: "220 mail.example.com ESMTP Postfix",
            80: "HTTP/1.1 200 OK Server: Nginx/1.18.0"
        }
        result = cve_lookup.get_service(banners)
        services = [svc for svc, _ in result]
        self.assertTrue(any(svc in services for svc in [
                        "vsFTPd", "Postfix", "Nginx"]))


class TestThreatIntelligence(unittest.TestCase):

    @patch("threat_intelligence.fetch_and_save")
    @patch("os.path.exists", return_value=True)
    def test_ensure_blacklist_file_exists_when_present(self, mock_exists, mock_fetch):
        path = threat_intelligence.ensure_blacklist_file_exists()
        self.assertTrue(path.endswith("blacklist_ips.txt"))
        mock_fetch.assert_not_called()

    @patch("threat_intelligence.fetch_and_save")
    @patch("os.makedirs")
    @patch(
        "os.path.exists",
        side_effect=lambda p: False if p.endswith(
            "blacklist_ips.txt") else True
    )
    def test_ensure_blacklist_file_exists_triggers_download(self, mock_exists, mock_makedirs, mock_fetch):
        path = threat_intelligence.ensure_blacklist_file_exists()
        mock_fetch.assert_called_once()
        self.assertTrue(path.endswith("blacklist_ips.txt"))

    @patch("threat_intelligence.open", new_callable=mock_open, read_data="1.2.3.4\n5.6.7.8\n")
    @patch("threat_intelligence.ensure_blacklist_file_exists", return_value="fakepath")
    @patch("os.path.exists", return_value=True)
    def test_is_ip_blacklisted_true(self, mock_exists, mock_ensure, mock_file):
        self.assertTrue(threat_intelligence.is_ip_blacklisted("1.2.3.4"))

    @patch("threat_intelligence.open", new_callable=mock_open, read_data="1.2.3.4\n")
    @patch("threat_intelligence.ensure_blacklist_file_exists", return_value="fakepath")
    @patch("os.path.exists", return_value=True)
    def test_is_ip_blacklisted_false(self, mock_exists, mock_ensure, mock_file):
        self.assertFalse(threat_intelligence.is_ip_blacklisted("8.8.8.8"))

    @patch("requests.get")
    @patch("threat_intelligence.open", new_callable=mock_open)
    @patch("os.makedirs")
    def test_fetch_and_save_downloads_and_saves(self, mock_makedirs, mock_file, mock_get):
        mock_get.side_effect = [
            type("Resp", (), {
                "text": "1.1.1.1\n#comment\n",
                "raise_for_status": staticmethod(lambda: None)
            })(),
            type("Resp", (), {
                "text": "2.2.2.2\n",
                "raise_for_status": staticmethod(lambda: None)
            })(),
        ]
        threat_intelligence.fetch_and_save()
        written_data = "".join(call.args[0]
                               for call in mock_file().write.call_args_list)
        self.assertIn("1.1.1.1", written_data)
        self.assertIn("2.2.2.2", written_data)


if __name__ == "__main__":
    unittest.main()
